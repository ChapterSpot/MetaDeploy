# Generated by Django 2.1.1 on 2018-09-17 17:48
"""
Ensure that there is at least one valid slug for every Product and Plan
model.

We could use the .ensure_slug methods on those models, except that if
those ever change, we don't want to change the logic of this migration,
which depends on the state of the database at this moment in time. So
we're basically inlining that logic.
"""

import itertools

from django.db import migrations
from django.utils.text import slugify


def find_unique_slug(original, slug_class):  # pragma: nocover
    max_length = 50  # This from SlugField

    candidate = original
    for i in itertools.count(1):
        if not slug_class.objects.filter(slug=candidate).exists():
            return candidate

        suffix = f'-{i}'
        candidate = candidate[:max_length - len(suffix)] + suffix


def forwards(apps, schema_editor):  # pragma: nocover
    Product = apps.get_model('api', 'Product')
    ProductSlug = apps.get_model('api', 'ProductSlug')
    Plan = apps.get_model('api', 'Plan')
    PlanSlug = apps.get_model('api', 'PlanSlug')

    for product in Product.objects.all():
        if not product.productslug_set.filter(is_active=True).exists():
            slug = slugify(product.title)
            slug = find_unique_slug(slug, ProductSlug)
            ProductSlug.objects.create(
                product=product,
                slug=slug,
                is_active=True,
            )

    for plan in Plan.objects.all():
        if not plan.planslug_set.filter(is_active=True).exists():
            slug = slugify(plan.title)
            slug = find_unique_slug(slug, PlanSlug)
            PlanSlug.objects.create(
                plan=plan,
                slug=slug,
                is_active=True,
            )


def backwards(apps, schema_editor):  # pragma: nocover
    pass


class Migration(migrations.Migration):

    dependencies = [
        ('api', '0011_planslug'),
    ]

    operations = [
        migrations.RunPython(forwards, backwards),
    ]
